// Generated by CoffeeScript 1.6.2
/*
    FJS compiler
    coffee fjs.coffee test
*/


(function() {
  var charByName, compileFunc, debugCompile, debugRuntime, decodeSymbol, depth, encodeSymbol, firstFunc, fs, funcOut, haveDbgInspect, i, localVarStack, longPad, nameByChar, path, src, symByWord, version, withStmntStack, wordBySym, _i;

  version = '0.0.0';

  debugCompile = false;

  debugRuntime = false;

  fs = require('fs');

  path = process.argv[2];

  longPad = '';

  for (i = _i = 0; _i <= 25; i = ++_i) {
    longPad += '     ';
  }

  withStmntStack = [];

  localVarStack = [];

  depth = 0;

  haveDbgInspect = false;

  firstFunc = true;

  funcOut = ("\n// File " + path + " compiled by FJS version " + version + " ") + ("on " + (new Date().toString().slice(0, 21)) + "\n\n");

  compileFunc = function(funcSrc, pfx, argCount) {
    var burnToEOL, colon, dbgArgs, dot, exists, getFuncString, getJsString, getString, gt, gtn, localVar, localVars, localVarsArr, lt, ltn, m, matches, mod, out, outFunc, rest, str, sym, topIdx, varSet, w, word, wordRegEx, _j, _k, _l, _len, _len1, _len2, _len3, _m, _ref, _ref1, _ref2, _ref3, _ref4, _ref5, _ref6;

    if (pfx == null) {
      pfx = 'this';
    }
    if (argCount == null) {
      argCount = 0;
    }
    getString = function(word, regex) {
      var chr0, chr1, delim, out, _ref;

      delim = word[0];
      out = delim;
      i = regex.lastIndex - word.length + 1;
      while (i < funcSrc.length) {
        chr0 = funcSrc[i];
        chr1 = (_ref = funcSrc[i + 1]) != null ? _ref : ' ';
        if (chr0 === '\\') {
          out += chr0 + chr1;
          i += 2;
          continue;
        }
        out += chr0;
        if (chr0 === delim && /\s/.test(chr1)) {
          regex.lastIndex = i + 1;
          return out;
        }
        i++;
      }
      throw new Exception('Unterminated string');
    };
    getJsString = function(word, regex) {
      var chr0, chr1, out, _ref;

      out = "";
      i = regex.lastIndex - word.length + 1;
      while (i < funcSrc.length) {
        chr0 = funcSrc[i];
        chr1 = (_ref = funcSrc[i + 1]) != null ? _ref : ' ';
        if (chr0 === '\\') {
          out += chr0 + chr1;
          i += 2;
          continue;
        }
        if (chr0 === "`" && /\s/.test(chr1)) {
          regex.lastIndex = i + 1;
          return out;
        }
        out += chr0;
        i++;
      }
      throw new Exception('Unterminated backtick string');
    };
    getFuncString = function(regex) {
      var chr0, chr1, chr2, out, _ref, _ref1;

      out = '';
      i = regex.lastIndex;
      while (i < funcSrc.length) {
        chr0 = funcSrc[i];
        chr1 = (_ref = funcSrc[i + 1]) != null ? _ref : ' ';
        chr2 = (_ref1 = funcSrc[i + 2]) != null ? _ref1 : ' ';
        if (chr0 === '\\') {
          out += chr0 + chr1;
          i += 2;
          continue;
        }
        if (/\s/.test(chr0) && chr1 === ')' && /\s/.test(chr2)) {
          regex.lastIndex = i + 2;
          return out;
        }
        out += chr0;
        i++;
      }
      throw new Exception('Unterminated function, missing right paren');
    };
    burnToEOL = function(regex) {
      var eolRegex;

      eolRegex = new RegExp('.*', 'gm');
      eolRegex.lastIndex = regex.lastIndex;
      eolRegex.exec(funcSrc);
      return regex.lastIndex = eolRegex.lastIndex;
    };
    out = function(word, line, dbgOk) {
      var dbgStr, str, _j;

      if (dbgOk == null) {
        dbgOk = true;
      }
      str = '';
      for (i = _j = 0; 0 <= depth ? _j < depth : _j > depth; i = 0 <= depth ? ++_j : --_j) {
        str += '  ';
      }
      str += line;
      if (word) {
        while (str.length < 75) {
          str += ' ';
        }
        dbgStr = '';
        if (debugRuntime && dbgOk) {
          dbgStr = longPad + 'fjsInspect.call(this, "' + word.replace(/"/g, "'") + '");';
        }
        return funcOut += str + ' /* ' + word + ' */' + dbgStr + '\n';
      } else {
        return funcOut += str + '\n';
      }
    };
    outFunc = function(pushArgCount, wordRegEx, exec, popArgCount) {
      var args;

      if (exec == null) {
        exec = true;
      }
      if (pushArgCount === '') {
        pushArgCount = 'Infinity';
      }
      if (popArgCount === '') {
        popArgCount = 'Infinity';
      }
      out(null, 'var fjs_func = function(){');
      depth++;
      if (pushArgCount != null) {
        out(null, 'var fjs_args = (Array.prototype.slice.call(');
        out(null, '    arguments, 0, (fjs_func.fjs_popArgCount || Infinity)));');
        args = (pushArgCount ? ', this.popN(' + pushArgCount + ') ' : ' ');
      } else {
        out(null, 'var fjs_args = [];');
        args = ' ';
      }
      compileFunc(getFuncString(wordRegEx));
      depth--;
      out(null, '}');
      if (popArgCount) {
        out(null, 'fjs_func.fjs_popArgCount = ' + popArgCount + ';');
      }
      if (exec) {
        return out('()', 'fjs_func.apply( this' + args + ');');
      } else {
        return out(null, 'this.push( fjs_func );');
      }
    };
    if (debugRuntime && !haveDbgInspect) {
      out(null, "function fjsInspect(fjs_word) {\n" + "  while(fjs_word.length < 25) fjs_word += ' ';\n" + "  fjs_stkDmp = []; fjs_frame = this.curFrame;\n" + "  if(fjs_frame) {\n" + "    fjs_stk = fjs_frame.stack; fjs_stkLen = fjs_stk.length;\n" + "    for(fjs_i=0; fjs_i<fjs_stkLen; fjs_i++) {\n" + "      fjs_item = fjs_stk[fjs_i];\n" + "      fjs_stkDmp.push(\n" + "        fjs_item === null ? 'null' : \n" + "        typeof fjs_item == 'string'  ? '\"'+fjs_item+'\"'          : \n" + "        typeof fjs_item == 'number'  ?  fjs_item                   : \n" + "        fjs_item instanceof Function ? 'function'                  : \n" + "        fjs_item instanceof Array    ? '['+fjs_item.toString()+']' : \n" + "        fjs_item instanceof Boolean  ? fjs_item.toString()         : \n" + "        (fjs_m = /^function\\s(.*?)\\(/.exec(fjs_item.constructor)) ? fjs_m[1] :\n" + "        fjs_item.toString()\n" + "      );\n" + "    }\n" + "  }\n" + "  console.log( 'dbg: ' + fjs_word, fjs_stkDmp.join(', '));\n" + "}\n");
      haveDbgInspect = true;
    }
    localVars = {};
    wordRegEx = new RegExp('\\s*(\\S+)', 'g');
    while ((matches = wordRegEx.exec(funcSrc))) {
      word = matches[1];
      if (/^\d*>\(|:?\(<\d*$/.test(word) || (word === '(' || word === ':(')) {
        break;
      }
      if ((word !== '=' && word !== '>=') && word.slice(-1) === '=') {
        word = word.slice(0, -1);
        exists = false;
        _ref = localVarStack != null ? localVarStack : [];
        for (_j = 0, _len = _ref.length; _j < _len; _j++) {
          varSet = _ref[_j];
          if (varSet[word]) {
            exists = true;
            break;
          }
        }
        if (!exists) {
          localVars[word] = true;
        }
      }
    }
    localVarStack.push(localVars);
    localVarsArr = [];
    for (localVar in localVars) {
      localVarsArr.push(encodeSymbol(localVar));
    }
    if (localVarsArr.length) {
      out(null, 'var ' + localVarsArr.join(', ') + ';');
    }
    dbgArgs = (!firstFunc ? dbgArgs = 'fjs_args, ' : '[], ');
    out(null, pfx + '.funcCall( ' + (debugRuntime ? 'fjsInspect' : 'null') + ', ' + dbgArgs, false);
    depth++;
    out(null, '[');
    depth++;
    out(null, 'function() {');
    depth++;
    if (!firstFunc) {
      out(null, 'this.pushArray(fjs_args);');
    }
    firstFunc = false;
    withStmntStack.push([]);
    wordRegEx = new RegExp('\\s*(\\S+)', 'g');
    while ((matches = wordRegEx.exec(funcSrc))) {
      word = matches[1];
      if (debugCompile) {
        console.log('word: ', word);
      }
      if (word.slice(0, 2) === '//') {
        burnToEOL(wordRegEx);
      } else if (word.slice(0, 5) === 'with:') {
        topIdx = withStmntStack.length - 1;
        sym = encodeSymbol(word.slice(5));
        withStmntStack[topIdx].push(sym);
        out(null, 'with( ' + sym + ' ) {');
        depth++;
      } else if (word.slice(0, 7) === 'typeof:') {
        sym = encodeSymbol(word.slice(7));
        out(word, 'this.push( typeof ' + sym + ' );');
        depth++;
      } else if (word.slice(0, 11) === 'instanceof:') {
        sym = encodeSymbol(word.slice(11));
        out(word, 'this.push( this.pop() instanceof ' + sym + ' );');
        depth++;
      } else if (word === 'cb') {
        out(word, 'this.pushCB(' + (debugRuntime ? 'fjsInspect' : 'null') + ');');
      } else if (word === 'wait') {
        out(word, 'this.wait();');
        _ref1 = withStmntStack[withStmntStack.length - 1];
        for (_k = 0, _len1 = _ref1.length; _k < _len1; _k++) {
          i = _ref1[_k];
          depth--;
          out(null, '}');
        }
        depth--;
        out(null, '}, function() {');
        depth++;
        _ref2 = withStmntStack[withStmntStack.length - 1];
        for (_l = 0, _len2 = _ref2.length; _l < _len2; _l++) {
          w = _ref2[_l];
          out(null, 'with( ' + encodeSymbol(w) + ' ) {');
          depth++;
        }
      } else if ((_ref3 = word[0]) === '"' || _ref3 === "'") {
        str = getString(word, wordRegEx);
        if (str.length > word.length) {
          word += ' ...';
        }
        out(word, 'this.push( ' + str + ' );');
      } else if (word[0] === "`") {
        str = getJsString(word, wordRegEx);
        if (str.length > word.length) {
          word += ' ...';
        }
        out(word, 'this.push( ' + str + ' );');
      } else if (word.length > 1 && word.slice(-1) === '=') {
        out(word, encodeSymbol(word.slice(0, -1)) + ' = this.pop();');
      } else if ((m = /^(:)?((\d*)>)?\((<(\d*))?$/.exec(word))) {
        _ref4 = m.slice(1), colon = _ref4[0], gt = _ref4[1], gtn = _ref4[2], lt = _ref4[3], ltn = _ref4[4];
        outFunc(gtn, wordRegEx, !colon, ltn);
      } else if ((matches = /^@(\d*)$/.exec(word))) {
        out(word, 'this.pushOuter( ' + matches[1] + ' );');
      } else if (word[0] === ':') {
        sym = encodeSymbol(word.slice(1));
        out(null, 'this.pushFuncOrSym( typeof ' + sym + ' == "undefined" ? null : ' + sym + ', "' + sym + '");');
        out(word, '');
      } else if ((m = /^(((\d*)>)?(\.)?)([^\s]+)/.exec(word))) {
        _ref5 = m.slice(1), mod = _ref5[0], gt = _ref5[1], gtn = _ref5[2], dot = _ref5[3], rest = _ref5[4];
        if (!mod) {
          out(word, 'this.execOrPush( ' + encodeSymbol(word) + ' );');
          continue;
        }
        sym = encodeSymbol(rest);
        if (dot) {
          out(null, 'fjs_ctxtObj = this.pop();');
          out(null, 'fjs_val = fjs_ctxtObj.' + sym + ';');
          if (gtn) {
            out(null, 'args = this.stack().splice(-' + gtn + ', ' + gtn + ')');
          }
          out(null, 'if(typeof fjs_val == "function")');
          if (gtn) {
            out(null, '  fjs_val = fjs_val.apply(fjs_ctxtObj, args);');
          } else if (gt) {
            out(null, '  fjs_val = fjs_val.apply(fjs_ctxtObj, this.popAll());');
          } else {
            out(null, '  fjs_val = fjs_val.call(fjs_ctxtObj);');
          }
          out(word, 'if(fjs_val != undefined) this.push(fjs_val);');
        } else {
          out(word, 'this.pushArgsAndExec( ' + sym + ', ' + (gtn || 'null') + ' );');
        }
      } else {
        out(sym, 'this.execOrPush( ' + encodeSymbol(sym) + ' );');
      }
    }
    out(')', 'this.funcReturn();');
    _ref6 = withStmntStack[withStmntStack.length - 1];
    for (_m = 0, _len3 = _ref6.length; _m < _len3; _m++) {
      i = _ref6[_m];
      depth--;
      out(null, '}');
    }
    depth--;
    out(null, '}');
    depth--;
    out(null, ']');
    withStmntStack.pop();
    localVarStack.pop();
    depth--;
    out(null, ');');
    if (debugCompile) {
      return console.log('word:  )');
    }
  };

  nameByChar = {
    '!': 'bang',
    '"': 'quot',
    '#': 'hash',
    '%': 'pcent',
    '&': 'amp',
    "'": 'tick',
    '(': 'lparen',
    ')': 'rparen',
    '*': 'star',
    '+': 'plus',
    ',': 'comma',
    '-': 'dash',
    '/': 'slash',
    ':': 'colon',
    ';': 'semi',
    '<': 'lt',
    '=': 'eq',
    '>': 'gt',
    '?': 'qmark',
    '@': 'at',
    '[': 'lbkt',
    '\\': 'bslsh',
    ']': 'rbkt',
    '^': 'caret',
    '`': 'btick',
    '{': 'lbrace',
    '|': 'pipe',
    '}': 'rbrace',
    '~': 'tilda'
  };

  charByName = {
    'bang': '!',
    'quot': '"',
    'hash': '#',
    'pcent': '%',
    'amp': '&',
    'tick': "'",
    'lparen': '(',
    'rparen': ')',
    'star': '*',
    'plus': '+',
    'comma': ',',
    'dash': '-',
    'slash': '/',
    'colon': ':',
    'semi': ';',
    'lt': '<',
    'eq': '=',
    'gt': '>',
    'qmark': '?',
    'at': '@',
    'lbkt': '[',
    'bslsh': '\\',
    'rbkt': ']',
    'caret': '^',
    'btick': '`',
    'lbrace': '{',
    'pipe': '|',
    'rbrace': '}',
    'tilda': '~'
  };

  symByWord = {
    "throw": '_throw_',
    "if": '_if_',
    "while": '_while_',
    '.': '_dot_',
    "new": '_new_'
  };

  wordBySym = {
    _throw_: 'throw',
    _if_: 'if',
    _while_: 'while',
    _dot_: '.',
    _new_: 'new'
  };

  encodeSymbol = function(str) {
    var char, name, out, _j, _len;

    if (str.length === 0) {
      return str;
    }
    if (str[0] === '`') {
      return str.slice(1);
    }
    if (str in symByWord) {
      return symByWord[str];
    }
    out = '';
    for (_j = 0, _len = str.length; _j < _len; _j++) {
      char = str[_j];
      if ((name = nameByChar[char])) {
        out += '_' + name + '_';
      } else {
        out += char;
      }
    }
    if (isNaN(out) && /^\d/.test(out)) {
      out = '_num_' + out;
    }
    return out;
  };

  decodeSymbol = function(str) {
    var char, name, regex;

    if (str in wordBySym) {
      return wordBySym[str];
    }
    for (name in charByName) {
      char = charByName[name];
      regex = new Regexp('_' + name + '_', 'g');
      str = str.replace(regex, char);
    }
    return str;
  };

  src = "'./fjs-primitives' >require fjs-primitives= with:fjs-primitives \n\n" + fs.readFileSync(path + '.fjs').toString();

  compileFunc(src, "require('./fjs-runtime')");

  fs.writeFile(path + '.js', funcOut);

}).call(this);
