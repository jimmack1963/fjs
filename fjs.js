// Generated by CoffeeScript 1.6.2
/*
    FJS compiler
    coffee fjs.coffee test
*/


(function() {
  var callDepth, charByName, compileFunc, debugCompile, debugRuntime, decodeSymbol, depth, encodeSymbol, fs, funcOut, haveDbgInspect, i, localVarIdxStk, localVarStack, longPad, nameByChar, path, src, symByWord, version, withStmntStack, wordBySym, _i;

  version = '0.1.0';

  debugCompile = false;

  debugRuntime = false;

  fs = require('fs');

  path = process.argv[2];

  longPad = '';

  for (i = _i = 0; _i <= 25; i = ++_i) {
    longPad += '     ';
  }

  withStmntStack = [];

  localVarStack = [];

  localVarIdxStk = [];

  callDepth = -1;

  depth = 0;

  haveDbgInspect = false;

  funcOut = ("\n// File " + path + " compiled by FJS version " + version + " ") + ("on " + (new Date().toString().slice(0, 21)) + "\n\n");

  compileFunc = function(funcSrc, pfx) {
    var dpth, exists, front, getFuncString, getString, idx, localVar, localVarIndexes, localVarsArr, ltn, m, matches, out, outFunc, parseWords, rest, restEsc, sym, topIdx, varSet, w, word, wordIdx, wordRegEx, wordsInLine, wrd, _, _j, _k, _l, _len, _len1, _len2, _len3, _len4, _len5, _m, _n, _o, _ref, _ref1, _ref2, _ref3, _ref4;

    getString = function(word, regex) {
      var chr0, chr1, delim, out, _ref;

      delim = word[0];
      out = delim;
      i = regex.lastIndex;
      while (i < funcSrc.length) {
        chr0 = funcSrc[i];
        chr1 = (_ref = funcSrc[i + 1]) != null ? _ref : ' ';
        if (chr0 === '\\') {
          out += chr0 + chr1;
          i += 2;
          continue;
        }
        out += chr0;
        if (chr0 === delim && /\s/.test(chr1)) {
          regex.lastIndex = i + 1;
          return out;
        }
        i++;
      }
      throw new Exception('Unterminated string');
    };
    getFuncString = function(word, regex) {
      var chr0, chr1, chr2, chr3, gs, out, wsIdx, _ref, _ref1, _ref2;

      out = word;
      i = regex.lastIndex;
      while (i < funcSrc.length) {
        chr0 = funcSrc[i];
        chr1 = (_ref = funcSrc[i + 1]) != null ? _ref : ' ';
        chr2 = (_ref1 = funcSrc[i + 2]) != null ? _ref1 : ' ';
        chr3 = (_ref2 = funcSrc[i + 3]) != null ? _ref2 : ' ';
        if (chr0 === '\\') {
          out += chr0 + chr1;
          i += 2;
          continue;
        }
        if (/\s/.test(chr0)) {
          if (chr1 === '/' && chr2 === '/') {
            while (++i < funcSrc.length && funcSrc[i] !== '\n') {undefined}
            continue;
          } else if (chr1 === '"' || chr1 === "'" || chr1 === "`") {
            regex.lastIndex = i + 2;
            out += chr0 + (gs = getString(chr1, regex));
            i = regex.lastIndex;
            continue;
          } else if (chr1 === '(' && /\s/.test(chr2)) {
            regex.lastIndex = i + 2;
            out += chr0 + getFuncString('(', regex);
            i = regex.lastIndex;
            continue;
          } else if (chr1 === ':' && chr2 === '(' && /\s/.test(chr3)) {
            regex.lastIndex = i + 3;
            out += chr0 + getFuncString(':(', regex);
            i = regex.lastIndex;
            continue;
          } else if (chr1 === ')') {
            wsIdx = i;
            while (++wsIdx < funcSrc.length && /\S/.test(funcSrc[wsIdx])) {undefined}
            regex.lastIndex = wsIdx;
            return out + funcSrc.slice(i, wsIdx);
          }
        }
        out += chr0;
        i++;
      }
      throw new Exception('Unmatched left paren');
    };
    parseWords = function(wordRegEx) {
      var comment, eolRegex, lastIndex, matches, whiteSpace, wordMatch, wordsInLine, _, _ref;

      wordsInLine = [];
      matches = true;
      lastIndex = wordRegEx.lastIndex;
      while (wordsInLine.length === 0 && matches) {
        while ((matches = wordRegEx.exec(funcSrc))) {
          _ = matches[0], wordMatch = matches[1], whiteSpace = matches[2];
          if ((comment = wordMatch.slice(0, 2) === '//')) {
            eolRegex = /\n|$/g;
            eolRegex.lastIndex = wordRegEx.lastIndex;
            eolRegex.exec(funcSrc);
            wordRegEx.lastIndex = eolRegex.lastIndex;
          } else {
            if ((_ref = wordMatch[0]) === '"' || _ref === "'" || _ref === "`") {
              wordRegEx.lastIndex = wordRegEx.lastIndex - wordMatch.length - whiteSpace.length + 1;
              wordMatch = getString(wordMatch, wordRegEx);
              whiteSpace = funcSrc[wordRegEx.lastIndex];
            } else if (/^:?\($/.test(wordMatch)) {
              wordRegEx.lastIndex = wordRegEx.lastIndex - whiteSpace.length;
              wordMatch = getFuncString(wordMatch, wordRegEx);
              whiteSpace = funcSrc[wordRegEx.lastIndex];
            }
            wordsInLine.unshift(wordMatch);
          }
          lastIndex = wordRegEx.lastIndex;
          if (comment || !whiteSpace || /\n/.test(whiteSpace)) {
            break;
          }
        }
        wordRegEx.lastIndex = lastIndex;
      }
      return wordsInLine;
    };
    out = function(word, line, dbgOk) {
      var dbgStr, str, _j;

      if (dbgOk == null) {
        dbgOk = true;
      }
      str = '';
      for (i = _j = 0; 0 <= depth ? _j < depth : _j > depth; i = 0 <= depth ? ++_j : --_j) {
        str += '  ';
      }
      str += line;
      if (word) {
        while (str.length < 75) {
          str += ' ';
        }
        dbgStr = '';
        if (debugRuntime && dbgOk) {
          dbgStr = longPad + 'fjsInspect.call(this, "' + word.replace(/"/g, "'") + '");';
        }
        return funcOut += str + ' /* ' + word + ' */' + dbgStr + '\n';
      } else {
        return funcOut += str + '\n';
      }
    };
    outFunc = function(src, exec) {
      var m, n;

      if (exec == null) {
        exec = true;
      }
      n = '';
      if ((m = /\)<(\d+)$/.exec(src))) {
        n = '0, ' + m[1];
      }
      if (exec) {
        if (n) {
          out(null, 'var fjs_argsArr = this.curFrame.stack.splice(' + n + ');');
        } else {
          out(null, 'var fjs_argsArr = this.curFrame.stack;');
          out(null, 'this.curFrame.stack = [];');
        }
        out(null, 'this.pushReturnValue( (function(){');
      } else {
        out(null, 'this.push( function(){');
      }
      depth++;
      out('(', 'this.setArgs(arguments);');
      if ((m = /^:?\((.*)\)<?(\d+)?$/.exec(src))) {
        src = m[1];
      }
      compileFunc(src, 'this');
      depth--;
      if (exec) {
        return out('()', '} ).apply( this, fjs_argsArr ));');
      } else {
        return out(null, '} );');
      }
    };
    if (debugRuntime && !haveDbgInspect) {
      out(null, "function fjsInspVal(fjs_stkDmp,fjs_item) {\n" + "   fjs_stkDmp.push(\n" + "     fjs_item === null ? 'null' : \n" + "     typeof fjs_item == 'string'  ? '\"'+fjs_item.replace(/\\s/g,' ')+'\"'          : \n" + "     typeof fjs_item == 'number'  ?  fjs_item                   : \n" + "     fjs_item instanceof Function ? 'function'                  : \n" + "     fjs_item instanceof Array    ? '['+fjs_item.toString()+']' : \n" + "     fjs_item instanceof Boolean  ? fjs_item.toString()         : \n" + "     (fjs_m = /^function\\s(.*?)\\(\\s/.exec(fjs_item.constructor)) ? fjs_m[1] :\n" + "     fjs_item.toString()\n" + "   );\n" + "}\n" + out(null, "function fjsInspect(fjs_word) {\n" + "  fjs_word = fjs_word.replace(/\\s/g,' ');" + "  while(fjs_word.length < 25) fjs_word += ' ';\n" + "  fjs_stkDmp = []; fjs_argDmp = []; fjs_frame = this.curFrame;\n" + "  if(fjs_frame) {\n" + "    fjs_stk = fjs_frame.stack; fjs_stkLen = fjs_stk.length;\n" + "    for(fjs_i=0; fjs_i<fjs_stkLen; fjs_i++)\n" + "      fjsInspVal(fjs_stkDmp,fjs_stk[fjs_i]);\n" + "    fjs_arg = fjs_frame.args; fjs_argLen = fjs_arg.length;\n" + "    for(fjs_i=0; fjs_i<fjs_argLen; fjs_i++)\n" + "      fjsInspVal(fjs_argDmp,fjs_arg[fjs_i]);\n" + "  }\n" + "  console.log( 'dbg: ' + fjs_word, '[ '+fjs_stkDmp.join(', ')+' ] /',\n" + "               '( '+fjs_argDmp.join(', ')+' )')\n" + "}\n"));
      haveDbgInspect = true;
    }
    localVarIndexes = {};
    wordRegEx = new RegExp('(\\S+)(\\s*)', 'g');
    wordIdx = -1;
    while ((wordsInLine = parseWords(wordRegEx)).length) {
      for (_j = 0, _len = wordsInLine.length; _j < _len; _j++) {
        word = wordsInLine[_j];
        wordIdx++;
        if ((word !== '=' && word !== '>=' && word !== '<=' && word !== 'not=') && word.slice(-1) === '=' && !/\./.test(word)) {
          word = word.slice(0, -1);
          exists = false;
          if (callDepth >= 0) {
            _ref = localVarStack.slice(0, +callDepth + 1 || 9e9);
            for (dpth = _k = 0, _len1 = _ref.length; _k < _len1; dpth = ++_k) {
              varSet = _ref[dpth];
              for (wrd in varSet) {
                idx = varSet[wrd];
                if (idx < localVarIdxStk[dpth]) {
                  if (wrd === word) {
                    exists = true;
                    break;
                  }
                }
              }
            }
          }
          if (!exists && !localVarIndexes[word]) {
            localVarIndexes[word] = wordIdx;
          }
        }
      }
    }
    withStmntStack.push([]);
    localVarStack.push(localVarIndexes);
    localVarIdxStk.push(-1);
    callDepth++;
    localVarsArr = [];
    for (localVar in localVarIndexes) {
      localVarsArr.push(encodeSymbol(localVar));
    }
    if (localVarsArr.length) {
      out(null, 'var ' + localVarsArr.join(', ') + ';');
    }
    out(null, pfx + '.funcCall( ' + (debugRuntime ? 'fjsInspect,' : 'null,'), false);
    depth++;
    out(null, '[');
    depth++;
    out(null, 'function() {');
    depth++;
    wordRegEx = new RegExp('(\\S+)(\\s*)', 'g');
    while ((wordsInLine = parseWords(wordRegEx)).length) {
      for (_l = 0, _len2 = wordsInLine.length; _l < _len2; _l++) {
        word = wordsInLine[_l];
        localVarIdxStk[callDepth]++;
        if (debugCompile) {
          console.log('- word:', localVarIdxStk[callDepth], word.slice(0, 61));
        }
        if ((_ref1 = word[0]) === '"' || _ref1 === "'") {
          out(word, 'this.push( ' + word + ' );');
        } else if (word[0] === "`") {
          out(word, 'this.push( ' + word.slice(1, -1) + ' );');
        } else if ((m = /^(:)?\(\s/.exec(word))) {
          outFunc(word, !m[1]);
        } else if (word.slice(0, 5) === 'with:') {
          topIdx = withStmntStack.length - 1;
          sym = encodeSymbol(word.slice(5));
          withStmntStack[topIdx].push(sym);
          out(null, 'with( ' + sym + ' ) {');
          depth++;
        } else if (word.slice(0, 7) === 'typeof:') {
          sym = encodeSymbol(word.slice(7));
          out(word, 'this.push( typeof ' + sym + ' );');
          depth++;
        } else if (word.slice(0, 11) === 'instanceof:') {
          sym = encodeSymbol(word.slice(11));
          out(word, 'this.push( this.pop() instanceof ' + sym + ' );');
          depth++;
        } else if (word === 'cb') {
          out(word, 'this.pushCB(' + (debugRuntime ? 'fjsInspect' : 'null') + ');');
        } else if (word === 'wait') {
          out(word, 'this.wait();');
          _ref2 = withStmntStack[withStmntStack.length - 1];
          for (_m = 0, _len3 = _ref2.length; _m < _len3; _m++) {
            i = _ref2[_m];
            depth--;
            out(null, '}');
          }
          depth--;
          out(null, '}, function() {');
          depth++;
          _ref3 = withStmntStack[withStmntStack.length - 1];
          for (_n = 0, _len4 = _ref3.length; _n < _len4; _n++) {
            w = _ref3[_n];
            out(null, 'with( ' + encodeSymbol(w) + ' ) {');
            depth++;
          }
        } else if (word[0] === ':') {
          rest = word.slice(1);
          restEsc = rest.replace(/"/g, '\\"');
          out(word, 'this.push( typeof ' + rest + ' == "function" ? ' + rest + ' : "' + restEsc + '" );');
        } else if (word.length > 1 && word.slice(-1) === '=') {
          out(word, (sym = encodeSymbol(word.slice(0, -1))) + ' = this.pop();');
        } else if ((matches = /^@(@|(\d*))$/.exec(word))) {
          ltn = (function() {
            switch (false) {
              case !!matches[1]:
                return 1;
              case !matches[2]:
                return matches[2];
              default:
                return '';
            }
          })();
          out(word, 'this.moveArgsToStack(' + ltn + ');');
        } else if ((m = /^(\S+)<(\d*)$/.exec(word))) {
          _ = m[0], front = m[1], ltn = m[2];
          ltn || (ltn = 'null');
          out(word, 'this.pushArgsAndExec( ' + encodeSymbol(front) + ', ' + ltn + ' );');
        } else if ((m = /^(\S+)\.$/.exec(word))) {
          if (!(front = m[1])) {
            out('.', 'this.execOrPush( _dot_ );');
          } else {
            sym = encodeSymbol(front);
            out(null, 'fjs_ctxtObj = this.pop();');
            out(null, 'fjs_val = fjs_ctxtObj.' + sym + ';');
            out(null, 'if(typeof fjs_val == "function")');
            out(null, '  fjs_val = fjs_val.apply(');
            out(null, '      fjs_ctxtObj, this.curFrame.stack );');
            out(null, '  this.curFrame.stack = [];');
            out(word, 'this.pushReturnValue(fjs_val);');
          }
        } else {
          out(word, 'this.execOrPush( ' + encodeSymbol(word) + ' );');
        }
      }
    }
    out(')', 'this.funcReturn();');
    _ref4 = withStmntStack[withStmntStack.length - 1];
    for (_o = 0, _len5 = _ref4.length; _o < _len5; _o++) {
      i = _ref4[_o];
      depth--;
      out(null, '}');
    }
    depth--;
    out(null, '}');
    depth--;
    out(null, ']');
    withStmntStack.pop();
    localVarStack.pop();
    localVarIdxStk.pop();
    callDepth--;
    depth--;
    out(null, ');');
    if (debugCompile) {
      return console.log('- word: ' + (localVarIdxStk[callDepth] + 1) + ' )');
    }
  };

  nameByChar = {
    '!': 'bang',
    '"': 'quot',
    '#': 'hash',
    '%': 'pcent',
    '&': 'amp',
    "'": 'tick',
    '(': 'lparen',
    ')': 'rparen',
    '*': 'star',
    '+': 'plus',
    ',': 'comma',
    '-': 'dash',
    '/': 'slash',
    ':': 'colon',
    ';': 'semi',
    '<': 'lt',
    '=': 'eq',
    '>': 'gt',
    '?': 'qmark',
    '@': 'at',
    '[': 'lbkt',
    '\\': 'bslsh',
    ']': 'rbkt',
    '^': 'caret',
    '`': 'btick',
    '{': 'lbrace',
    '|': 'pipe',
    '}': 'rbrace',
    '~': 'tilda'
  };

  charByName = {
    'bang': '!',
    'quot': '"',
    'hash': '#',
    'pcent': '%',
    'amp': '&',
    'tick': "'",
    'lparen': '(',
    'rparen': ')',
    'star': '*',
    'plus': '+',
    'comma': ',',
    'dash': '-',
    'slash': '/',
    'colon': ':',
    'semi': ';',
    'lt': '<',
    'eq': '=',
    'gt': '>',
    'qmark': '?',
    'at': '@',
    'lbkt': '[',
    'bslsh': '\\',
    'rbkt': ']',
    'caret': '^',
    'btick': '`',
    'lbrace': '{',
    'pipe': '|',
    'rbrace': '}',
    'tilda': '~'
  };

  symByWord = {
    "throw": '_throw_',
    "if": '_if_',
    "while": '_while_',
    '.': '_dot_',
    "new": '_new_'
  };

  wordBySym = {
    _throw_: 'throw',
    _if_: 'if',
    _while_: 'while',
    _dot_: '.',
    _new_: 'new'
  };

  encodeSymbol = function(str) {
    var char, name, out, _j, _len;

    if (str.length === 0) {
      return str;
    }
    if (str[0] === '`') {
      return str.slice(1);
    }
    if (str in symByWord) {
      return symByWord[str];
    }
    out = '';
    for (_j = 0, _len = str.length; _j < _len; _j++) {
      char = str[_j];
      if ((name = nameByChar[char])) {
        out += '_' + name + '_';
      } else {
        out += char;
      }
    }
    if (isNaN(out) && /^\d/.test(out)) {
      out = '_num_' + out;
    }
    return out;
  };

  decodeSymbol = function(str) {
    var char, name, regex;

    if (str in wordBySym) {
      return wordBySym[str];
    }
    for (name in charByName) {
      char = charByName[name];
      regex = new Regexp('_' + name + '_', 'g');
      str = str.replace(regex, char);
    }
    return str;
  };

  src = "with:fjs-primitives  fjs-primitives=  require './fjs-primitives'\n\n" + fs.readFileSync(path + '.fjs').toString();

  compileFunc(src, "require('./fjs-runtime')");

  fs.writeFile(path + '.js', funcOut);

}).call(this);
