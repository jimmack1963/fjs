// Generated by CoffeeScript 1.6.2
/*
    FJS compiler
    coffee fjs.coffee test
*/


(function() {
  var charByName, compileFunc, debugCompile, debugRuntime, decodeSymbol, depth, encodeSymbol, fs, funcOut, haveDbgInspect, i, localVarStack, longPad, nameByChar, path, src, symByWord, version, withStmntStack, wordBySym, _i;

  version = '0.1.0';

  debugCompile = true;

  debugRuntime = false;

  fs = require('fs');

  path = process.argv[2];

  longPad = '';

  for (i = _i = 0; _i <= 25; i = ++_i) {
    longPad += '     ';
  }

  withStmntStack = [];

  localVarStack = [];

  depth = 0;

  haveDbgInspect = false;

  funcOut = ("\n// File " + path + " compiled by FJS version " + version + " ") + ("on " + (new Date().toString().slice(0, 21)) + "\n\n");

  compileFunc = function(funcSrc, pfx) {
    var comment, dot, exists, front, getFuncString, getString, localVar, localVars, localVarsArr, m, matches, out, outFunc, sym, topIdx, varSet, w, whiteSpace, word, wordMatch, wordRegEx, wordsInLine, _, _j, _k, _l, _len, _len1, _len2, _len3, _len4, _len5, _m, _n, _o, _ref, _ref1, _ref2, _ref3, _ref4;

    if (pfx == null) {
      pfx = 'this';
    }
    getString = function(word, regex) {
      var chr0, chr1, delim, out, _ref;

      delim = word[0];
      out = delim;
      i = regex.lastIndex - word.length + 1;
      while (i < funcSrc.length) {
        chr0 = funcSrc[i];
        chr1 = (_ref = funcSrc[i + 1]) != null ? _ref : ' ';
        if (chr0 === '\\') {
          out += chr0 + chr1;
          i += 2;
          continue;
        }
        out += chr0;
        if (chr0 === delim && /\s/.test(chr1)) {
          regex.lastIndex = i + 1;
          return out;
        }
        i++;
      }
      throw new Exception('Unterminated string');
    };
    getFuncString = function(word, regex) {
      var chr0, chr1, chr2, chr3, out, _ref, _ref1, _ref2;

      out = word;
      i = regex.lastIndex;
      while (i < funcSrc.length) {
        chr0 = funcSrc[i];
        chr1 = (_ref = funcSrc[i + 1]) != null ? _ref : ' ';
        chr2 = (_ref1 = funcSrc[i + 2]) != null ? _ref1 : ' ';
        chr3 = (_ref2 = funcSrc[i + 3]) != null ? _ref2 : ' ';
        if (chr0 === '\\') {
          out += chr0 + chr1;
          i += 2;
          continue;
        }
        if (/\s/.test(chr0)) {
          if (chr0 === '/' && chr1 === '/') {
            while (++i < funcSrc.length && funcSrc[i] !== '\n') {undefined}
            continue;
          } else if (chr1 === '"' || chr1 === "'" || chr1 === "`") {
            regex.lastIndex = i + 2;
            out += chr0 + getString(chr1, regex);
            i = regex.lastIndex;
            continue;
          } else if (chr1 === '(' && /\s/.test(chr2)) {
            regex.lastIndex = i + 2;
            out += chr0 + getFuncString('(', regex);
            i = regex.lastIndex;
            continue;
          } else if (chr1 === ':' && chr2 === '(' && /\s/.test(chr3)) {
            regex.lastIndex = i + 3;
            out += chr0 + getFuncString(':(', regex);
            i = regex.lastIndex;
            continue;
          } else if (chr1 === ')' && /\s/.test(chr2)) {
            regex.lastIndex = i + 2;
            return out + chr0 + ')';
          }
        }
        out += chr0;
        i++;
      }
      throw new Exception('Unmatched left paren');
    };
    out = function(word, line, dbgOk) {
      var dbgStr, str, _j;

      if (dbgOk == null) {
        dbgOk = true;
      }
      str = '';
      for (i = _j = 0; 0 <= depth ? _j < depth : _j > depth; i = 0 <= depth ? ++_j : --_j) {
        str += '  ';
      }
      str += line;
      if (word) {
        while (str.length < 75) {
          str += ' ';
        }
        dbgStr = '';
        if (debugRuntime && dbgOk) {
          dbgStr = longPad + 'fjsInspect.call(this, "' + word.replace(/"/g, "'") + '");';
        }
        return funcOut += str + ' /* ' + word + ' */' + dbgStr + '\n';
      } else {
        return funcOut += str + '\n';
      }
    };
    outFunc = function(word, exec) {
      if (exec == null) {
        exec = true;
      }
      if (debugCompile) {
        console.log('outFunc', word.length, exec);
      }
      if (exec) {
        out(null, '( function(){');
      } else {
        out(null, 'this.pushReturnValue( function(){');
      }
      depth++;
      compileFunc(word);
      depth--;
      out(null, '}');
      if (exec) {
        out('()', '} ).apply( this, this.curFrame.stack );');
        return out(null, 'this.curFrame.stack = [];');
      } else {
        return out(null, '} );');
      }
    };
    if (debugRuntime && !haveDbgInspect) {
      out(null, "function fjsInspect(fjs_word) {\n" + "  while(fjs_word.length < 25) fjs_word += ' ';\n" + "  fjs_stkDmp = []; fjs_frame = this.curFrame;\n" + "  if(fjs_frame) {\n" + "    fjs_stk = fjs_frame.stack; fjs_stkLen = fjs_stk.length;\n" + "    for(fjs_i=0; fjs_i<fjs_stkLen; fjs_i++) {\n" + "      fjs_item = fjs_stk[fjs_i];\n" + "      fjs_stkDmp.push(\n" + "        fjs_item === null ? 'null' : \n" + "        typeof fjs_item == 'string'  ? '\"'+fjs_item+'\"'          : \n" + "        typeof fjs_item == 'number'  ?  fjs_item                   : \n" + "        fjs_item instanceof Function ? 'function'                  : \n" + "        fjs_item instanceof Array    ? '['+fjs_item.toString()+']' : \n" + "        fjs_item instanceof Boolean  ? fjs_item.toString()         : \n" + "        (fjs_m = /^function\\s(.*?)\\(/.exec(fjs_item.constructor)) ? fjs_m[1] :\n" + "        fjs_item.toString()\n" + "      );\n" + "    }\n" + "  }\n" + "  console.log( 'dbg: ' + fjs_word, fjs_stkDmp.join(', '));\n" + "}\n");
      haveDbgInspect = true;
    }
    localVars = {};
    wordsInLine = [];
    wordRegEx = new RegExp('(\\S+)(\\s*)', 'g');
    while ((matches = wordRegEx.exec(funcSrc))) {
      _ = matches[0], wordMatch = matches[1], whiteSpace = matches[2];
      wordsInLine.push(wordMatch);
      if (!whiteSpace || /\n/.test(whiteSpace || wordRegEx.lastIndex === funcSrc.length)) {
        wordsInLine.reverse();
        for (_j = 0, _len = wordsInLine.length; _j < _len; _j++) {
          word = wordsInLine[_j];
          if (/^\d*>\(|:?\(<\d*$/.test(word) || (word === '(' || word === ':(')) {
            break;
          }
          if ((word !== '=' && word !== '>=') && word.slice(-1) === '=') {
            word = word.slice(0, -1);
            exists = false;
            _ref = localVarStack != null ? localVarStack : [];
            for (_k = 0, _len1 = _ref.length; _k < _len1; _k++) {
              varSet = _ref[_k];
              if (varSet[word]) {
                exists = true;
                break;
              }
            }
            if (!exists) {
              localVars[word] = true;
            }
          }
        }
        wordsInLine = [];
      }
    }
    localVarStack.push(localVars);
    localVarsArr = [];
    for (localVar in localVars) {
      localVarsArr.push(encodeSymbol(localVar));
    }
    if (localVarsArr.length) {
      out(null, 'var ' + localVarsArr.join(', ') + ';');
    }
    out(null, pfx + '.funcCall( ' + (debugRuntime ? 'fjsInspect,' : 'null,'), false);
    depth++;
    out(null, '[');
    depth++;
    out(null, 'function() {');
    depth++;
    withStmntStack.push([]);
    wordsInLine = [];
    wordRegEx = new RegExp('(\\S+)(\\s*)', 'g');
    while ((matches = wordRegEx.exec(funcSrc))) {
      _ = matches[0], wordMatch = matches[1], whiteSpace = matches[2];
      if (!(comment = wordMatch.slice(0, 2) === '//')) {
        if ((_ref1 = wordMatch[0]) === '"' || _ref1 === "'" || _ref1 === "`") {
          wordMatch = getString(wordMatch, wordRegEx);
        } else if (/^:?\($/.test(wordMatch)) {
          wordMatch = getFuncString(wordMatch, wordRegEx);
        }
        wordsInLine.push(wordMatch);
      }
      if (comment || !whiteSpace || /\n/.test(whiteSpace) || wordRegEx.lastIndex === funcSrc.length) {
        wordsInLine.reverse();
        for (_l = 0, _len2 = wordsInLine.length; _l < _len2; _l++) {
          word = wordsInLine[_l];
          if (debugCompile) {
            console.log('word: ', word.slice(0, 21));
          }
          if (word.slice(0, 5) === 'with:') {
            topIdx = withStmntStack.length - 1;
            sym = encodeSymbol(word.slice(5));
            withStmntStack[topIdx].push(sym);
            out(null, 'with( ' + sym + ' ) {');
            depth++;
          } else if (word.slice(0, 7) === 'typeof:') {
            sym = encodeSymbol(word.slice(7));
            out(word, 'this.push( typeof ' + sym + ' );');
            depth++;
          } else if (word.slice(0, 11) === 'instanceof:') {
            sym = encodeSymbol(word.slice(11));
            out(word, 'this.push( this.pop() instanceof ' + sym + ' );');
            depth++;
          } else if (word === 'cb') {
            out(word, 'this.pushCB(' + (debugRuntime ? 'fjsInspect' : 'null') + ');');
          } else if (word === 'wait') {
            out(word, 'this.wait();');
            _ref2 = withStmntStack[withStmntStack.length - 1];
            for (_m = 0, _len3 = _ref2.length; _m < _len3; _m++) {
              i = _ref2[_m];
              depth--;
              out(null, '}');
            }
            depth--;
            out(null, '}, function() {');
            depth++;
            _ref3 = withStmntStack[withStmntStack.length - 1];
            for (_n = 0, _len4 = _ref3.length; _n < _len4; _n++) {
              w = _ref3[_n];
              out(null, 'with( ' + encodeSymbol(w) + ' ) {');
              depth++;
            }
          } else if (word.length > 1 && word.slice(-1) === '=') {
            out(word, encodeSymbol(word.slice(0, -1)) + ' = this.pop();');
          } else if ((m = /^(:)?\($/.exec(word))) {
            outFunc(word, !m[1]);
          } else if ((matches = /^@(\d*)$/.exec(word))) {
            out(word, 'this.pushOuter( ' + matches[1] + ' );');
          } else if (word[0] === ':') {
            out(word, 'this.push( "' + (word.replace(/"/g, '\\"')) + '" );');
          } else if ((m = /^(\S+)(\.)?$/.exec(word))) {
            _ = m[0], front = m[1], dot = m[2];
            if (!front) {
              if (dot) {
                out('.', 'this.execOrPush( _dot_ );');
              }
            } else {
              sym = encodeSymbol(front);
              if (!dot) {
                out(word, 'this.execOrPush( ' + sym + ' );');
              } else {
                out(null, 'fjs_ctxtObj = this.pop();');
                out(null, 'fjs_val = fjs_ctxtObj.' + sym + ';');
                out(null, 'if(typeof fjs_val == "function")');
                out(null, '  fjs_val = fjs_val.apply(');
                out(null, '      fjs_ctxtObj, this.curFrame.stack );');
                out(word, 'if(fjs_val != undefined) this.pushReturnValue(fjs_val);');
              }
            }
          }
        }
        wordsInLine = [];
      }
    }
    out(')', 'this.funcReturn();');
    _ref4 = withStmntStack[withStmntStack.length - 1];
    for (_o = 0, _len5 = _ref4.length; _o < _len5; _o++) {
      i = _ref4[_o];
      depth--;
      out(null, '}');
    }
    depth--;
    out(null, '}');
    depth--;
    out(null, ']');
    withStmntStack.pop();
    localVarStack.pop();
    depth--;
    out(null, ');');
    if (debugCompile) {
      return console.log('word:  )');
    }
  };

  nameByChar = {
    '!': 'bang',
    '"': 'quot',
    '#': 'hash',
    '%': 'pcent',
    '&': 'amp',
    "'": 'tick',
    '(': 'lparen',
    ')': 'rparen',
    '*': 'star',
    '+': 'plus',
    ',': 'comma',
    '-': 'dash',
    '/': 'slash',
    ':': 'colon',
    ';': 'semi',
    '<': 'lt',
    '=': 'eq',
    '>': 'gt',
    '?': 'qmark',
    '@': 'at',
    '[': 'lbkt',
    '\\': 'bslsh',
    ']': 'rbkt',
    '^': 'caret',
    '`': 'btick',
    '{': 'lbrace',
    '|': 'pipe',
    '}': 'rbrace',
    '~': 'tilda'
  };

  charByName = {
    'bang': '!',
    'quot': '"',
    'hash': '#',
    'pcent': '%',
    'amp': '&',
    'tick': "'",
    'lparen': '(',
    'rparen': ')',
    'star': '*',
    'plus': '+',
    'comma': ',',
    'dash': '-',
    'slash': '/',
    'colon': ':',
    'semi': ';',
    'lt': '<',
    'eq': '=',
    'gt': '>',
    'qmark': '?',
    'at': '@',
    'lbkt': '[',
    'bslsh': '\\',
    'rbkt': ']',
    'caret': '^',
    'btick': '`',
    'lbrace': '{',
    'pipe': '|',
    'rbrace': '}',
    'tilda': '~'
  };

  symByWord = {
    "throw": '_throw_',
    "if": '_if_',
    "while": '_while_',
    '.': '_dot_',
    "new": '_new_'
  };

  wordBySym = {
    _throw_: 'throw',
    _if_: 'if',
    _while_: 'while',
    _dot_: '.',
    _new_: 'new'
  };

  encodeSymbol = function(str) {
    var char, name, out, _j, _len;

    if (str.length === 0) {
      return str;
    }
    if (str[0] === '`') {
      return str.slice(1);
    }
    if (str in symByWord) {
      return symByWord[str];
    }
    out = '';
    for (_j = 0, _len = str.length; _j < _len; _j++) {
      char = str[_j];
      if ((name = nameByChar[char])) {
        out += '_' + name + '_';
      } else {
        out += char;
      }
    }
    if (isNaN(out) && /^\d/.test(out)) {
      out = '_num_' + out;
    }
    return out;
  };

  decodeSymbol = function(str) {
    var char, name, regex;

    if (str in wordBySym) {
      return wordBySym[str];
    }
    for (name in charByName) {
      char = charByName[name];
      regex = new Regexp('_' + name + '_', 'g');
      str = str.replace(regex, char);
    }
    return str;
  };

  src = "with:fjs-primitives  fjs-primitives=  require './fjs-primitives'\n\n" + fs.readFileSync(path + '.fjs').toString();

  compileFunc(src, "require('./fjs-runtime')");

  fs.writeFile(path + '.js', funcOut);

}).call(this);
