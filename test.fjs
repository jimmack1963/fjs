
// -------- Examples from the docs --------

"\nFrom the *Hello World* section" . drop*
    . 'Hello World'

"\nFrom the *Comments* section" . drop*
    . + 1 1   // prints "2" on stdout
    . * 1 1   // prints "1" on stdout

"\nFrom the *Named Variables* section" . drop*
    x= 3 // assign 3 to variable x
    . x  // prints "3"

"\nFrom the *Functions* section" . drop*
    ( . "hello world" )                   // creates and runs function, prints "hello world"
    printGreeting= :( . "hello world" )   // creates function and assigns it to a variable
    printGreeting						  // runs function, prints "hello world"

"\nFrom the *Word Modifers* section" . drop*
    . Math.min  1 2 3   // prints "3" (Math.max(1, 3, 2))   Leaves empty stack
    . min. Math 1 2 3   // prints "3" (Math.max(1, 3, 2))   Leaves empty stack

"\nFrom the *Word Modifers* section" . drop*
	.  x x= 1		// prints "1"
	. :x x= 1		// prints "x"
	.  Math.min		// prints "Infinity"
	. :Math.min     // prints "[Function: min]"
	.  ( + 1 2 )    // prints "3"
	. :( + 1 2 )	// prints "[Function]"

"\nFrom the *Number/Asterisk Convention* section" . drop*
    .2 1 2 3      // prints two items, "1 2", and leaves one item on the stack
    .* 1 2 3      // prints all three, "1 2 3" and leaves the stack empty
    drop* 1 2 3   // empties entire stack

"\nFrom the *Multiple Stacks* section" . drop*
    ( . Math.max @2 ) 1 2 3  // prints "2" and leaves one item on stack
    ( .  @ . @ . @ )  1 2 3  // prints "1", then "2", then "3"
    ( .* @3 )         1 2 3  // prints "1 2 3"

"\nFrom the *Function Results* section" . drop*
    .*  (   1 2 3 )   // prints "1 2 3"
    .*  ( + 1 2 3 )   // prints "3 3"
    . + ( + 1 2 3 )   // prints "6"

"\nFrom the *Named Variable Scopes* section" . drop*
	  x= 1		// assign 1 to x
	( y= 2 )	// anonymous function executed with var y in local scope
	. typeof:y  // prints "undefined"
	( x= 3 )  	// var x is from outer scope
	. x 		// prints 3, not 1

"\nFrom the *Async Execution* section" . drop*
	fs= require 'fs'  // load the fs module and assing it to the fs variable.
	.* wait ( . 'hello world' ) fs.readFile 'fjs.bat' 'utf8' cb
                      // prints "hello world" and then the error code and file contents

"\nFrom the *Primitve Words* section" . drop*
    fjs-primitives= require './fjs-primitives'
    with:fjs-primitives

"\nFrom the *Modules* section" . drop*
    fs= require 'fs'             	// load module and save it in fs var
    fs.writefileSync 'hello world' 	// use fs as the namespace for write

"\nFrom the *Modules* section" . drop*
     exports.increment= ( + 1 @ )	// The `increment` function is exported from the module

"\nFrom the *Embedding Javascript Code* section" . drop*
    . `x = 1 + 1` 		// assigns 2 to x and prints "2"
    obj= `{a:1, b:2}` 	// assigns a constant object to the variable `obj`

"\nFrom the *Special Operator Prefixes* section" . drop*
	obj= `{x:1}` 		    	// assign object to var obj
    ( . x with:obj )			// prints 1 (`with` goes to end of function
    . typeof:x  			    // prints "undefined"

// -------- Standard Javascript http server example from Node --------
//   var http = require('http');
//   http.createServer(function (req, res) {
//     res.writeHead(200, {'Content-Type': 'text/plain'});
//     res.end('Hello World\n');
//   }).listen(1337, '127.0.0.1');
//   console.log('Server running at http://127.0.0.1:1337/');

    createServer. ( require 'http' ) cb
    drop ( listen. @ 1337 '127.0.0.1' )
    dup drop swap wait . 'Server running at http://127.0.0.1:1337/'
        ( writeHead. @ 200 `{'Content-Type':'text/plain'}` )
        ( end.       @ 200 'Hello World'                   )



