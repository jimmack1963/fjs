// Generated by CoffeeScript 1.6.2
/*
    FJS primitive functions
*/


(function() {
  var __slice = [].slice;

  module.exports = {
    _new_: function() {
      var args;

      args = 1 <= arguments.length ? __slice.call(arguments, 0) : [];
      if (args.length === 0) {
        return this["new"](this.pop());
      } else {
        return this["new"](args.pop(), args);
      }
    },
    _dot_: function() {
      var args;

      args = 1 <= arguments.length ? __slice.call(arguments, 0) : [];
      if (args.length === 0) {
        console.log(this.pop());
      } else {
        console.log.apply(console, args);
      }
      return void 0;
    },
    swap: function() {
      var args, stack, stkLen, top;

      args = 1 <= arguments.length ? __slice.call(arguments, 0) : [];
      if (args.length === 0) {
        stack = this.stack();
        if ((stkLen = stack.length) > 1) {
          top = stack[stkLen - 1];
          stack[stkLen - 1] = stack[stkLen - 2];
          stack[stkLen - 2] = top;
        }
        return void 0;
      } else {
        return args.slice(-1).concat(args.slice(0, -1));
      }
    },
    dup: function() {
      var args, stack;

      args = 1 <= arguments.length ? __slice.call(arguments, 0) : [];
      if (args.length === 0) {
        stack = this.stack();
        return stack[stack.length - 1];
      } else {
        return args.concat(args);
      }
    },
    over: function() {
      var args, stack, stkLen;

      args = 1 <= arguments.length ? __slice.call(arguments, 0) : [];
      if (args.length === 0) {
        stack = this.stack();
        if ((stkLen = stack.length) > 1) {
          return stack[stkLen - 2];
        }
      } else {
        return args.concat(args.slice(0, 1));
      }
    },
    rot: function() {
      var args, bot, stack, stkLen;

      args = 1 <= arguments.length ? __slice.call(arguments, 0) : [];
      if (args.length === 0) {
        stack = this.stack();
        if ((stkLen = stack.length) < 3) {
          exports.swap();
        } else {
          bot = stack[stkLen - 3];
          stack[stkLen - 3] = stack[stkLen - 2];
          stack[stkLen - 2] = stack[stkLen - 1];
          stack[stkLen - 1] = bot;
        }
        return void 0;
      } else {
        return args.slice(1).concat(args.slice(0, 1));
      }
    },
    drop: function() {
      var args;

      args = 1 <= arguments.length ? __slice.call(arguments, 0) : [];
      if (args.length === 0) {
        this.pop();
      }
      return void 0;
    },
    _plus_: function() {
      var arg, args, haveStr, stack, stkLen, top, total, _i, _j, _len, _len1;

      args = 1 <= arguments.length ? __slice.call(arguments, 0) : [];
      if (args.length === 0) {
        stack = this.stack();
        if ((stkLen = stack.length) > 1) {
          top = this.pop();
          stack[stkLen - 2] = stack[stkLen - 2] + top;
          return void 0;
        }
      } else {
        haveStr = false;
        for (_i = 0, _len = args.length; _i < _len; _i++) {
          arg = args[_i];
          if (typeof arg === 'string') {
            haveStr = true;
            break;
          }
        }
        total = (haveStr ? '' : 0);
        for (_j = 0, _len1 = args.length; _j < _len1; _j++) {
          arg = args[_j];
          total += arg;
        }
        return total;
      }
    },
    _dash_: function() {
      var args, argsLen, i, stack, stkLen, top, _i, _ref;

      args = 1 <= arguments.length ? __slice.call(arguments, 0) : [];
      if ((argsLen = args.length) === 0) {
        stack = this.stack();
        if ((stkLen = stack.length) > 1) {
          top = this.pop();
          stack[stkLen - 2] = stack[stkLen - 2] - top;
        } else if (stkLen === 1) {
          stack[0] = -stack[0];
        }
        return void 0;
      } else {
        top = args.pop();
        for (i = _i = 0, _ref = argsLen - 2; 0 <= _ref ? _i <= _ref : _i >= _ref; i = 0 <= _ref ? ++_i : --_i) {
          args[i] -= top;
        }
        return args;
      }
    },
    _star_: function() {
      var args, argsLen, i, stack, stkLen, top, _i, _ref;

      args = 1 <= arguments.length ? __slice.call(arguments, 0) : [];
      if ((argsLen = args.length) === 0) {
        stack = this.stack();
        if ((stkLen = stack.length) > 1) {
          top = this.pop();
          stack[stkLen - 2] = stack[stkLen - 2] * top;
          return void 0;
        }
      } else {
        top = args.pop();
        for (i = _i = 0, _ref = argsLen - 2; 0 <= _ref ? _i <= _ref : _i >= _ref; i = 0 <= _ref ? ++_i : --_i) {
          args[i] *= top;
        }
        return args;
      }
    },
    _slash_: function() {
      var args, argsLen, i, stack, stkLen, top, _i, _ref;

      args = 1 <= arguments.length ? __slice.call(arguments, 0) : [];
      if ((argsLen = args.length) === 0) {
        stack = this.stack();
        if ((stkLen = stack.length) > 1) {
          top = this.pop();
          stack[stkLen - 2] = stack[stkLen - 2] / top;
        }
        return void 0;
      } else {
        top = args.pop();
        for (i = _i = 0, _ref = argsLen - 2; 0 <= _ref ? _i <= _ref : _i >= _ref; i = 0 <= _ref ? ++_i : --_i) {
          args[i] /= top;
        }
        return args;
      }
    },
    _eq_: function() {
      var args, argsLen, i, top, _i, _ref;

      args = 1 <= arguments.length ? __slice.call(arguments, 0) : [];
      if ((argsLen = args.length) === 0) {
        return this.pop() === this.pop();
      } else {
        top = args.pop();
        for (i = _i = 0, _ref = argsLen - 2; 0 <= _ref ? _i <= _ref : _i >= _ref; i = 0 <= _ref ? ++_i : --_i) {
          args[i] = args[i] === top;
        }
        return args;
      }
    },
    _lt: function() {
      var args, argsLen, i, top, _i, _ref;

      args = 1 <= arguments.length ? __slice.call(arguments, 0) : [];
      if ((argsLen = args.length) === 0) {
        return this.pop() > this.pop();
      } else {
        top = args.pop();
        for (i = _i = 0, _ref = argsLen - 2; 0 <= _ref ? _i <= _ref : _i >= _ref; i = 0 <= _ref ? ++_i : --_i) {
          args[i] = args[i] < top;
        }
        return args;
      }
    },
    _gt_: function() {
      var args, i, top, _i, _ref;

      args = 1 <= arguments.length ? __slice.call(arguments, 0) : [];
      if (args.length === 0) {
        return this.pop() < this.pop();
      } else {
        top = args.pop();
        for (i = _i = 0, _ref = argsLen - 2; 0 <= _ref ? _i <= _ref : _i >= _ref; i = 0 <= _ref ? ++_i : --_i) {
          args[i] = args[i] > top;
        }
        return args;
      }
    },
    truthy: function() {
      var args, argsLen, i, stack, stkLenM1, _i, _ref;

      args = 1 <= arguments.length ? __slice.call(arguments, 0) : [];
      if ((argsLen = args.length) === 0) {
        stack = this.stack();
        stkLenM1 = stack.length - 1;
        return stack[stkLenM1] = !!stack[stkLenM1];
      } else {
        for (i = _i = 0, _ref = argsLen - 1; 0 <= _ref ? _i <= _ref : _i >= _ref; i = 0 <= _ref ? ++_i : --_i) {
          args[i] = !!args[i];
        }
        return args;
      }
    },
    not: function() {
      var args, argsLen, i, _i, _ref;

      args = 1 <= arguments.length ? __slice.call(arguments, 0) : [];
      if ((argsLen = args.length) === 0) {
        return !this.pop();
      } else {
        for (i = _i = 0, _ref = argsLen - 1; 0 <= _ref ? _i <= _ref : _i >= _ref; i = 0 <= _ref ? ++_i : --_i) {
          args[i] = !args[i];
        }
        return args;
      }
    },
    _if_: function() {
      var args, argsLen, cond, func, _i, _len, _ref;

      args = 1 <= arguments.length ? __slice.call(arguments, 0) : [];
      if ((argsLen = args.length) === 0) {
        this.pop().call(this);
        cond = this.pop();
        func = this.pop();
        if (cond) {
          if (func.fjs_popArgCount) {
            this.pushArgsAndExec(func, func.fjs_popArgCount);
          } else {
            this.execOrPush(func);
          }
        }
      } else {
        args.pop().call(this);
        cond = this.pop();
        if (cond) {
          _ref = args.slice(0, +(argsLen - 2) + 1 || 9e9);
          for (_i = 0, _len = _ref.length; _i < _len; _i++) {
            func = _ref[_i];
            if (func.fjs_popArgCount) {
              this.pushArgsAndExec(func, func.fjs_popArgCount);
            } else {
              this.execOrPush(func);
            }
          }
        }
      }
      return void 0;
    },
    _while_: function() {
      var argsLen, cond, func, _i, _len, _ref;

      if ((argsLen = args.length) === 0) {
        cond = this.pop();
        func = this.pop();
        while (true) {
          if (cond != null) {
            cond.call(this);
          }
          if (this.pop()) {
            this.execOrPush.call(this, func);
          } else {
            break;
          }
        }
      } else {
        cond = args.pop();
        while (true) {
          if (cond != null) {
            cond.call(this);
          }
          if (this.pop()) {
            _ref = args.slice(0, +(argsLen - 2) + 1 || 9e9);
            for (_i = 0, _len = _ref.length; _i < _len; _i++) {
              func = _ref[_i];
              this.execOrPush.call(this, func);
            }
          } else {
            break;
          }
        }
      }
      return void 0;
    }
  };

  exports._throw_ = function() {
    throw JSON.stringify(this);
  };

}).call(this);
